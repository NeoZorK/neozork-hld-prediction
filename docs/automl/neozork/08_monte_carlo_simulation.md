# 08. ðŸŽ² ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ

**Ð¦ÐµÐ»ÑŒ:** ÐÐ°ÑƒÑ‡Ð¸Ñ‚ÑŒÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸ÑŽ Ð´Ð»Ñ Ð¾Ñ†ÐµÐ½ÐºÐ¸ Ñ€Ð¸ÑÐºÐ¾Ð² Ð¸ Ð½ÐµÐ¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸ Ñ‚Ð¾Ñ€Ð³Ð¾Ð²Ñ‹Ñ… ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¹.

## Ð§Ñ‚Ð¾ Ñ‚Ð°ÐºÐ¾Ðµ ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ?

**ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ** - ÑÑ‚Ð¾ Ð¼ÐµÑ‚Ð¾Ð´ Ð¼Ð¾Ð´ÐµÐ»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ðµ Ð²Ñ‹Ð±Ð¾Ñ€ÐºÐ¸ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ñ‡Ð¸ÑÐ»ÐµÐ½Ð½Ñ‹Ñ… Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² Ð¸ Ð¾Ñ†ÐµÐ½ÐºÐ¸ Ð½ÐµÐ¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸.

### Ð—Ð°Ñ‡ÐµÐ¼ Ð½ÑƒÐ¶Ð½Ð° ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ?
- **ÐžÑ†ÐµÐ½ÐºÐ° Ñ€Ð¸ÑÐºÐ¾Ð²** - Ð¿Ð¾Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ñ… Ð¿Ð¾Ñ‚ÐµÑ€ÑŒ
- **ÐŸÐ»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ°Ð¿Ð¸Ñ‚Ð°Ð»Ð°** - Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¹
- **Ð¡Ñ‚Ñ€ÐµÑÑ-Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ** - Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð² ÑÐºÑÑ‚Ñ€ÐµÐ¼Ð°Ð»ÑŒÐ½Ñ‹Ñ… ÑƒÑÐ»Ð¾Ð²Ð¸ÑÑ…
- **Ð’Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸** - Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ñ€Ð¾Ð±Ð°ÑÑ‚Ð½Ð¾ÑÑ‚Ð¸

## ÐžÑÐ½Ð¾Ð²Ñ‹ ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ð¸

### 1. ÐŸÑ€Ð¾ÑÑ‚Ð°Ñ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ
```python
import numpy as np
import pandas as pd
from scipy import stats

def monte_carlo_simulation(returns, n_simulations=10000, time_horizon=252):
    """ÐŸÑ€Ð¾ÑÑ‚Ð°Ñ ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ"""
    
    # ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸
    mean_return = returns.mean()
    std_return = returns.std()
    
    # ÐœÐ°ÑÑÐ¸Ð² Ð´Ð»Ñ Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
    simulation_results = []
    
    for _ in range(n_simulations):
        # Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ñ… Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚ÐµÐ¹
        random_returns = np.random.normal(mean_return, std_return, time_horizon)
        
        # Ð Ð°ÑÑ‡ÐµÑ‚ ÐºÑƒÐ¼ÑƒÐ»ÑÑ‚Ð¸Ð²Ð½Ð¾Ð¹ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸
        cumulative_return = np.prod(1 + random_returns) - 1
        
        simulation_results.append(cumulative_return)
    
    return np.array(simulation_results)

def analyze_simulation_results(results):
    """ÐÐ½Ð°Ð»Ð¸Ð· Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ð¸"""
    
    return {
        'mean_return': np.mean(results),
        'std_return': np.std(results),
        'percentile_5': np.percentile(results, 5),
        'percentile_25': np.percentile(results, 25),
        'percentile_50': np.percentile(results, 50),
        'percentile_75': np.percentile(results, 75),
        'percentile_95': np.percentile(results, 95),
        'probability_positive': np.mean(results > 0),
        'probability_loss': np.mean(results < 0),
        'max_loss': np.min(results),
        'max_gain': np.max(results)
    }
```

### 2. Bootstrap ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ
```python
def bootstrap_monte_carlo(returns, n_simulations=10000, time_horizon=252):
    """Bootstrap ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ"""
    
    simulation_results = []
    
    for _ in range(n_simulations):
        # Ð¡Ð»ÑƒÑ‡Ð°Ð¹Ð½Ð°Ñ Ð²Ñ‹Ð±Ð¾Ñ€ÐºÐ° Ñ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸ÐµÐ¼
        bootstrap_returns = np.random.choice(returns, size=time_horizon, replace=True)
        
        # Ð Ð°ÑÑ‡ÐµÑ‚ ÐºÑƒÐ¼ÑƒÐ»ÑÑ‚Ð¸Ð²Ð½Ð¾Ð¹ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸
        cumulative_return = np.prod(1 + bootstrap_returns) - 1
        
        simulation_results.append(cumulative_return)
    
    return np.array(simulation_results)
```

### 3. Block Bootstrap ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ
```python
def block_bootstrap_monte_carlo(returns, n_simulations=10000, time_horizon=252, block_size=5):
    """Block Bootstrap ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ"""
    
    simulation_results = []
    
    for _ in range(n_simulations):
        # Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ¾Ð²
        n_blocks = time_horizon // block_size
        bootstrap_returns = []
        
        for _ in range(n_blocks):
            # Ð¡Ð»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ð¹ Ð²Ñ‹Ð±Ð¾Ñ€ Ð±Ð»Ð¾ÐºÐ°
            start_idx = np.random.randint(0, len(returns) - block_size)
            block = returns[start_idx:start_idx + block_size]
            bootstrap_returns.extend(block)
        
        # Ð”Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð´Ð¾ Ð½ÑƒÐ¶Ð½Ð¾Ð¹ Ð´Ð»Ð¸Ð½Ñ‹
        while len(bootstrap_returns) < time_horizon:
            start_idx = np.random.randint(0, len(returns) - block_size)
            block = returns[start_idx:start_idx + block_size]
            bootstrap_returns.extend(block)
        
        bootstrap_returns = np.array(bootstrap_returns[:time_horizon])
        
        # Ð Ð°ÑÑ‡ÐµÑ‚ ÐºÑƒÐ¼ÑƒÐ»ÑÑ‚Ð¸Ð²Ð½Ð¾Ð¹ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸
        cumulative_return = np.prod(1 + bootstrap_returns) - 1
        
        simulation_results.append(cumulative_return)
    
    return np.array(simulation_results)
```

## ÐŸÑ€Ð¾Ð´Ð²Ð¸Ð½ÑƒÑ‚Ñ‹Ðµ Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ¸

### 1. Ð£Ñ‡ÐµÑ‚ Ð°Ð²Ñ‚Ð¾ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸Ð¸
```python
def autocorrelated_monte_carlo(returns, n_simulations=10000, time_horizon=252):
    """ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ Ñ ÑƒÑ‡ÐµÑ‚Ð¾Ð¼ Ð°Ð²Ñ‚Ð¾ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸Ð¸"""
    
    # Ð Ð°ÑÑ‡ÐµÑ‚ Ð°Ð²Ñ‚Ð¾ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸Ð¸
    autocorr = pd.Series(returns).autocorr(lag=1)
    
    simulation_results = []
    
    for _ in range(n_simulations):
        # Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ñ ÑƒÑ‡ÐµÑ‚Ð¾Ð¼ Ð°Ð²Ñ‚Ð¾ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸Ð¸
        simulated_returns = []
        
        # ÐŸÐµÑ€Ð²Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ
        first_return = np.random.normal(returns.mean(), returns.std())
        simulated_returns.append(first_return)
        
        # ÐŸÐ¾ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ñ Ð°Ð²Ñ‚Ð¾ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸ÐµÐ¹
        for i in range(1, time_horizon):
            # AR(1) Ð¿Ñ€Ð¾Ñ†ÐµÑÑ
            next_return = (autocorr * simulated_returns[-1] + 
                          np.random.normal(0, returns.std() * np.sqrt(1 - autocorr**2)))
            simulated_returns.append(next_return)
        
        # Ð Ð°ÑÑ‡ÐµÑ‚ ÐºÑƒÐ¼ÑƒÐ»ÑÑ‚Ð¸Ð²Ð½Ð¾Ð¹ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸
        cumulative_return = np.prod(1 + simulated_returns) - 1
        simulation_results.append(cumulative_return)
    
    return np.array(simulation_results)
```

### 2. Ð£Ñ‡ÐµÑ‚ Ð²Ð¾Ð»Ð°Ñ‚Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚Ð¸
```python
def garch_monte_carlo(returns, n_simulations=10000, time_horizon=252):
    """ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ Ñ GARCH Ð¼Ð¾Ð´ÐµÐ»ÑŒÑŽ Ð²Ð¾Ð»Ð°Ñ‚Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚Ð¸"""
    
    from arch import arch_model
    
    # ÐžÐ±ÑƒÑ‡ÐµÐ½Ð¸Ðµ GARCH Ð¼Ð¾Ð´ÐµÐ»Ð¸
    model = arch_model(returns, vol='Garch', p=1, q=1)
    fitted_model = model.fit()
    
    simulation_results = []
    
    for _ in range(n_simulations):
        # Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ñ GARCH Ð²Ð¾Ð»Ð°Ñ‚Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒÑŽ
        simulated_returns = fitted_model.forecast(horizon=time_horizon, method='simulation')
        
        # Ð Ð°ÑÑ‡ÐµÑ‚ ÐºÑƒÐ¼ÑƒÐ»ÑÑ‚Ð¸Ð²Ð½Ð¾Ð¹ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸
        cumulative_return = np.prod(1 + simulated_returns.values.flatten()) - 1
        simulation_results.append(cumulative_return)
    
    return np.array(simulation_results)
```

### 3. ÐœÐ½Ð¾Ð³Ð¾Ð¼ÐµÑ€Ð½Ð°Ñ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ
```python
def multivariate_monte_carlo(returns_dict, n_simulations=10000, time_horizon=252):
    """ÐœÐ½Ð¾Ð³Ð¾Ð¼ÐµÑ€Ð½Ð°Ñ ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ"""
    
    # ÐžÐ±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    returns_df = pd.DataFrame(returns_dict)
    
    # Ð Ð°ÑÑ‡ÐµÑ‚ ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸Ð¾Ð½Ð½Ð¾Ð¹ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹
    correlation_matrix = returns_df.corr()
    
    # Cholesky Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ
    chol_matrix = np.linalg.cholesky(correlation_matrix)
    
    simulation_results = {}
    
    for asset in returns_dict.keys():
        asset_returns = returns_dict[asset]
        mean_return = asset_returns.mean()
        std_return = asset_returns.std()
        
        asset_simulations = []
        
        for _ in range(n_simulations):
            # Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ð½ÐµÐ·Ð°Ð²Ð¸ÑÐ¸Ð¼Ñ‹Ñ… ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ»
            independent_random = np.random.normal(0, 1, time_horizon)
            
            # ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ñ ÑƒÑ‡ÐµÑ‚Ð¾Ð¼ ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸Ð¹
            correlated_random = chol_matrix @ independent_random
            
            # Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚ÐµÐ¹
            simulated_returns = mean_return + std_return * correlated_random
            
            # Ð Ð°ÑÑ‡ÐµÑ‚ ÐºÑƒÐ¼ÑƒÐ»ÑÑ‚Ð¸Ð²Ð½Ð¾Ð¹ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸
            cumulative_return = np.prod(1 + simulated_returns) - 1
            asset_simulations.append(cumulative_return)
        
        simulation_results[asset] = np.array(asset_simulations)
    
    return simulation_results
```

## ÐÐ½Ð°Ð»Ð¸Ð· Ñ€Ð¸ÑÐºÐ¾Ð²

### 1. Value at Risk (VaR)
```python
def calculate_var(simulation_results, confidence_level=0.05):
    """Ð Ð°ÑÑ‡ÐµÑ‚ Value at Risk"""
    
    var = np.percentile(simulation_results, confidence_level * 100)
    return var

def calculate_expected_shortfall(simulation_results, confidence_level=0.05):
    """Ð Ð°ÑÑ‡ÐµÑ‚ Expected Shortfall (Conditional VaR)"""
    
    var = calculate_var(simulation_results, confidence_level)
    tail_losses = simulation_results[simulation_results <= var]
    expected_shortfall = np.mean(tail_losses)
    
    return expected_shortfall
```

### 2. Maximum Drawdown
```python
def calculate_max_drawdown_distribution(simulation_results, time_horizon=252):
    """Ð Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð¹ Ð¿Ñ€Ð¾ÑÐ°Ð´ÐºÐ¸"""
    
    max_drawdowns = []
    
    for result in simulation_results:
        # Ð¡Ð¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ Ð¿ÑƒÑ‚Ð¸ ÐºÐ°Ð¿Ð¸Ñ‚Ð°Ð»Ð°
        cumulative_returns = np.cumprod(1 + np.random.normal(0, 0.02, time_horizon))
        
        # Ð Ð°ÑÑ‡ÐµÑ‚ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð¹ Ð¿Ñ€Ð¾ÑÐ°Ð´ÐºÐ¸
        running_max = np.maximum.accumulate(cumulative_returns)
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = np.min(drawdown)
        
        max_drawdowns.append(max_drawdown)
    
    return np.array(max_drawdowns)
```

### 3. Stress Testing
```python
def stress_testing_monte_carlo(returns, stress_scenarios, n_simulations=10000):
    """Ð¡Ñ‚Ñ€ÐµÑÑ-Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ñ ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾"""
    
    stress_results = {}
    
    for scenario_name, stress_params in stress_scenarios.items():
        # ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÑÑ‚Ñ€ÐµÑÑÐ°
        stress_mean = stress_params.get('mean', returns.mean())
        stress_std = stress_params.get('std', returns.std() * stress_params.get('volatility_multiplier', 1))
        stress_correlation = stress_params.get('correlation', 1)
        
        scenario_results = []
        
        for _ in range(n_simulations):
            # Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ñ ÑÑ‚Ñ€ÐµÑÑÐ¾Ð²Ñ‹Ð¼Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼Ð¸
            stress_returns = np.random.normal(stress_mean, stress_std, len(returns))
            
            # ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ ÐºÐ¾Ñ€Ñ€ÐµÐ»ÑÑ†Ð¸Ð¸
            if stress_correlation != 1:
                stress_returns = stress_correlation * returns + np.sqrt(1 - stress_correlation**2) * stress_returns
            
            # Ð Ð°ÑÑ‡ÐµÑ‚ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð°
            cumulative_return = np.prod(1 + stress_returns) - 1
            scenario_results.append(cumulative_return)
        
        stress_results[scenario_name] = np.array(scenario_results)
    
    return stress_results
```

## Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²

### 1. Ð Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
```python
import matplotlib.pyplot as plt

def plot_simulation_distribution(simulation_results, title="ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ"):
    """Ð“Ñ€Ð°Ñ„Ð¸Ðº Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ð¸"""
    
    plt.figure(figsize=(12, 8))
    
    # Ð“Ð¸ÑÑ‚Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð°
    plt.hist(simulation_results, bins=50, alpha=0.7, density=True, edgecolor='black')
    
    # ÐÐ¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ ÑÑ€Ð°Ð²Ð½ÐµÐ½Ð¸Ñ
    mu, sigma = np.mean(simulation_results), np.std(simulation_results)
    x = np.linspace(simulation_results.min(), simulation_results.max(), 100)
    plt.plot(x, stats.norm.pdf(x, mu, sigma), 'r-', linewidth=2, label='ÐÐ¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ')
    
    # ÐšÐ²Ð°Ð½Ñ‚Ð¸Ð»Ð¸
    percentiles = [5, 25, 50, 75, 95]
    for p in percentiles:
        value = np.percentile(simulation_results, p)
        plt.axvline(value, color='red', linestyle='--', alpha=0.7, label=f'{p}%: {value:.3f}')
    
    plt.title(title)
    plt.xlabel('Ð”Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚ÑŒ')
    plt.ylabel('ÐŸÐ»Ð¾Ñ‚Ð½Ð¾ÑÑ‚ÑŒ')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()
```

### 2. ÐšÑ€Ð¸Ð²Ð°Ñ Ñ€Ð¸ÑÐºÐ°
```python
def plot_risk_curve(simulation_results, confidence_levels):
    """ÐšÑ€Ð¸Ð²Ð°Ñ Ñ€Ð¸ÑÐºÐ° (VaR)"""
    
    var_values = []
    
    for cl in confidence_levels:
        var = np.percentile(simulation_results, cl * 100)
        var_values.append(var)
    
    plt.figure(figsize=(10, 6))
    plt.plot(confidence_levels, var_values, marker='o', linewidth=2)
    plt.title('ÐšÑ€Ð¸Ð²Ð°Ñ Ñ€Ð¸ÑÐºÐ° (VaR)')
    plt.xlabel('Ð£Ñ€Ð¾Ð²ÐµÐ½ÑŒ Ð´Ð¾Ð²ÐµÑ€Ð¸Ñ')
    plt.ylabel('VaR')
    plt.grid(True, alpha=0.3)
    plt.show()
```

### 3. Ð¡Ñ€Ð°Ð²Ð½ÐµÐ½Ð¸Ðµ ÑÑ†ÐµÐ½Ð°Ñ€Ð¸ÐµÐ²
```python
def plot_scenario_comparison(stress_results):
    """Ð¡Ñ€Ð°Ð²Ð½ÐµÐ½Ð¸Ðµ ÑÑ‚Ñ€ÐµÑÑÐ¾Ð²Ñ‹Ñ… ÑÑ†ÐµÐ½Ð°Ñ€Ð¸ÐµÐ²"""
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    axes = axes.flatten()
    
    for i, (scenario_name, results) in enumerate(stress_results.items()):
        if i < len(axes):
            axes[i].hist(results, bins=30, alpha=0.7, edgecolor='black')
            axes[i].set_title(f'Ð¡Ñ†ÐµÐ½Ð°Ñ€Ð¸Ð¹: {scenario_name}')
            axes[i].set_xlabel('Ð”Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚ÑŒ')
            axes[i].set_ylabel('Ð§Ð°ÑÑ‚Ð¾Ñ‚Ð°')
            axes[i].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()
```

## ÐŸÑ€Ð°ÐºÑ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð¿Ñ€Ð¸Ð¼ÐµÑ€

```python
def complete_monte_carlo_analysis(returns, n_simulations=10000):
    """ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð·"""
    
    # 1. ÐŸÑ€Ð¾ÑÑ‚Ð°Ñ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ
    simple_results = monte_carlo_simulation(returns, n_simulations)
    
    # 2. Bootstrap ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ
    bootstrap_results = bootstrap_monte_carlo(returns, n_simulations)
    
    # 3. Block Bootstrap ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ
    block_bootstrap_results = block_bootstrap_monte_carlo(returns, n_simulations)
    
    # 4. ÐÐ½Ð°Ð»Ð¸Ð· Ñ€Ð¸ÑÐºÐ¾Ð²
    var_95 = calculate_var(simple_results, 0.05)
    var_99 = calculate_var(simple_results, 0.01)
    es_95 = calculate_expected_shortfall(simple_results, 0.05)
    
    # 5. Ð¡Ñ‚Ñ€ÐµÑÑ-Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ
    stress_scenarios = {
        'ÐšÑ€Ð¸Ð·Ð¸Ñ': {'volatility_multiplier': 2.0, 'mean': -0.01},
        'Ð’Ñ‹ÑÐ¾ÐºÐ°Ñ Ð²Ð¾Ð»Ð°Ñ‚Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒ': {'volatility_multiplier': 1.5},
        'ÐÐ¸Ð·ÐºÐ°Ñ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚ÑŒ': {'mean': 0.001}
    }
    
    stress_results = stress_testing_monte_carlo(returns, stress_scenarios)
    
    # 6. Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ
    plot_simulation_distribution(simple_results, "ÐŸÑ€Ð¾ÑÑ‚Ð°Ñ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ")
    plot_simulation_distribution(bootstrap_results, "Bootstrap ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ")
    plot_scenario_comparison(stress_results)
    
    # 7. ÐžÑ‚Ñ‡ÐµÑ‚
    analysis = analyze_simulation_results(simple_results)
    
    print("=== ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð· ===")
    print(f"Ð¡Ñ€ÐµÐ´Ð½ÑÑ Ð´Ð¾Ñ…Ð¾Ð´Ð½Ð¾ÑÑ‚ÑŒ: {analysis['mean_return']:.2%}")
    print(f"Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ðµ Ð¾Ñ‚ÐºÐ»Ð¾Ð½ÐµÐ½Ð¸Ðµ: {analysis['std_return']:.2%}")
    print(f"5% VaR: {var_95:.2%}")
    print(f"1% VaR: {var_99:.2%}")
    print(f"Expected Shortfall (95%): {es_95:.2%}")
    print(f"Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ñ€Ð¸Ð±Ñ‹Ð»Ð¸: {analysis['probability_positive']:.2%}")
    print(f"Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ ÑƒÐ±Ñ‹Ñ‚ÐºÐ°: {analysis['probability_loss']:.2%}")
    
    return {
        'simple_results': simple_results,
        'bootstrap_results': bootstrap_results,
        'block_bootstrap_results': block_bootstrap_results,
        'stress_results': stress_results,
        'risk_metrics': {
            'var_95': var_95,
            'var_99': var_99,
            'es_95': es_95
        },
        'analysis': analysis
    }
```

## Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ðµ ÑˆÐ°Ð³Ð¸

ÐŸÐ¾ÑÐ»Ðµ ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ð¸ Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ð¸Ñ‚Ðµ Ðº:
- **[09_risk_management.md](09_risk_management.md)** - Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ€Ð¸ÑÐºÐ°Ð¼Ð¸
- **[10_blockchain_deployment.md](10_blockchain_deployment.md)** - Ð‘Ð»Ð¾ÐºÑ‡ÐµÐ¹Ð½ Ð´ÐµÐ¿Ð»Ð¾Ð¹

## ÐšÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ Ð²Ñ‹Ð²Ð¾Ð´Ñ‹

1. **ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾** - Ð¼Ð¾Ñ‰Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¾Ñ†ÐµÐ½ÐºÐ¸ Ñ€Ð¸ÑÐºÐ¾Ð²
2. **Bootstrap** ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
3. **Ð¡Ñ‚Ñ€ÐµÑÑ-Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ** Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ ÑƒÑÑ‚Ð¾Ð¹Ñ‡Ð¸Ð²Ð¾ÑÑ‚ÑŒ
4. **VaR Ð¸ ES** - ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸ Ñ€Ð¸ÑÐºÐ°
5. **Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ** Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÐµÑ‚ Ð¿Ð¾Ð½ÑÑ‚ÑŒ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ€Ð¸ÑÐºÐ¾Ð²

---

**Ð’Ð°Ð¶Ð½Ð¾:** ÐœÐ¾Ð½Ñ‚Ðµ-ÐšÐ°Ñ€Ð»Ð¾ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð½Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑƒÑŽ Ð¿Ñ€Ð¸Ð±Ñ‹Ð»ÑŒ, Ð½Ð¾ Ð¸ Ñ€Ð¸ÑÐºÐ¸ Ð¿Ð¾Ñ‚ÐµÑ€ÑŒ!
