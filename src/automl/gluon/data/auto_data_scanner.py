"""
Auto Data Scanner for Trading Strategy Pipeline
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–∫–∞–Ω–µ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–∞–π–ø–ª–∞–π–Ω–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π

Automatically scans csv_converted folder and extracts indicators, symbols, and timeframes
from filenames like "SHORT3_GBPUSD_PERIOD_H1.parquet"
"""

import os
import re
import pandas as pd
from pathlib import Path
from typing import Dict, List, Set, Tuple, Optional, Any
import logging
from collections import defaultdict

logger = logging.getLogger(__name__)


class AutoDataScanner:
    """
    Automatically scans data directory and extracts available indicators, symbols, and timeframes.
    –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫–∞–Ω–∏—Ä—É–µ—Ç –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–∞–Ω–Ω—ã—Ö –∏ –∏–∑–≤–ª–µ–∫–∞–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã, —Å–∏–º–≤–æ–ª—ã –∏ —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã.
    """
    
    def __init__(self, data_path: str = "data/cache/csv_converted/"):
        """
        Initialize Auto Data Scanner.
        
        Args:
            data_path: Path to data directory
        """
        self.data_path = Path(data_path)
        self.available_data = {}
        self.indicators = set()
        self.symbols = set()
        self.timeframes = set()
        
        # Supported timeframes in order of importance
        self.timeframe_order = ['M1', 'M5', 'M15', 'H1', 'H4', 'D1', 'W1', 'MN1']
        
    def scan_directory(self) -> Dict[str, Any]:
        """
        Scan directory for available data files.
        –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –¥–∞–Ω–Ω—ã—Ö.
        
        Returns:
            Dictionary with scan results
        """
        logger.info(f"üîç Scanning directory: {self.data_path}")
        
        if not self.data_path.exists():
            logger.error(f"‚ùå Data path does not exist: {self.data_path}")
            return {'error': f'Data path does not exist: {self.data_path}'}
        
        # Pattern to match filenames like "INDICATOR_SYMBOL_PERIOD_TIMEFRAME.parquet"
        # Supports CSVExport (SCHR Levels), WAVE2, SHORT3, and other indicators
        # Updated pattern to include CSVExport files with dots in symbols (e.g., AAPL.NAS)
        # CSVExport files have format: CSVExport_SYMBOL_PERIOD_TIMEFRAME.parquet
        # Other indicators have format: INDICATOR_SYMBOL_PERIOD_TIMEFRAME.parquet
        # We need to handle both formats
        csv_export_pattern = r'^CSVExport_([A-Z0-9.]+)_PERIOD_([A-Z0-9]+)\.parquet$'
        other_pattern = r'^([A-Z0-9_]+)_([A-Z0-9.]+)_PERIOD_([A-Z0-9]+)\.parquet$'
        
        available_files = []
        
        # Scan for parquet files
        for file_path in self.data_path.glob("*.parquet"):
            filename = file_path.name
            
            # Try CSVExport pattern first
            csv_match = re.match(csv_export_pattern, filename)
            if csv_match:
                symbol, timeframe = csv_match.groups()
                indicator = "CSVExport"  # CSVExport is the indicator name
            else:
                # Try other pattern
                other_match = re.match(other_pattern, filename)
                if other_match:
                    indicator, symbol, timeframe = other_match.groups()
                else:
                    continue  # Skip files that don't match either pattern
            
            # Get file info
            file_info = {
                'file_path': str(file_path),
                'filename': filename,
                'indicator': indicator,
                'symbol': symbol,
                'timeframe': timeframe,
                'size_mb': file_path.stat().st_size / (1024 * 1024),
                'exists': True
            }
            
            available_files.append(file_info)
            
            # Update sets
            self.indicators.add(indicator)
            self.symbols.add(symbol)
            self.timeframes.add(timeframe)
            
            logger.info(f"‚úÖ Found: {indicator} {symbol} {timeframe} ({file_info['size_mb']:.1f} MB)")
        else:
                logger.warning(f"‚ö†Ô∏è Skipped file (doesn't match pattern): {filename}")
        
        # Organize data by indicator and symbol
        self.available_data = self._organize_data(available_files)
        
        scan_results = {
            'total_files': len(available_files),
            'indicators': sorted(list(self.indicators)),
            'symbols': sorted(list(self.symbols)),
            'timeframes': sorted(list(self.timeframes)),
            'available_data': self.available_data,
            'scan_successful': True
        }
        
        logger.info(f"üìä Scan completed: {len(available_files)} files, {len(self.indicators)} indicators, {len(self.symbols)} symbols")
        
        return scan_results
    
    def _organize_data(self, files: List[Dict]) -> Dict[str, Dict[str, List[Dict]]]:
        """
        Organize data by indicator and symbol.
        –û—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞–º –∏ —Å–∏–º–≤–æ–ª–∞–º.
        """
        organized = defaultdict(lambda: defaultdict(list))
        
        for file_info in files:
            indicator = file_info['indicator']
            symbol = file_info['symbol']
            organized[indicator][symbol].append(file_info)
        
        # Sort timeframes by importance
        for indicator in organized:
            for symbol in organized[indicator]:
                organized[indicator][symbol].sort(
                    key=lambda x: self.timeframe_order.index(x['timeframe']) 
                    if x['timeframe'] in self.timeframe_order else 999
                )
        
        return dict(organized)
    
    def get_available_combinations(self) -> Dict[str, List[str]]:
        """
        Get available indicator-symbol combinations.
        –ü–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä-—Å–∏–º–≤–æ–ª.
        
        Returns:
            Dictionary with available combinations
        """
        combinations = {}
        
        for indicator in self.available_data:
            symbols = list(self.available_data[indicator].keys())
            combinations[indicator] = symbols
        
        return combinations
    
    def get_symbol_timeframes(self, indicator: str, symbol: str) -> List[str]:
        """
        Get available timeframes for specific indicator-symbol combination.
        –ü–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä-—Å–∏–º–≤–æ–ª.
        
        Args:
            indicator: Indicator name
            symbol: Symbol name
            
        Returns:
            List of available timeframes
        """
        if indicator not in self.available_data:
            return []
        
        if symbol not in self.available_data[indicator]:
            return []
        
        timeframes = [file_info['timeframe'] for file_info in self.available_data[indicator][symbol]]
        return sorted(timeframes, key=lambda x: self.timeframe_order.index(x) if x in self.timeframe_order else 999)
    
    def get_file_path(self, indicator: str, symbol: str, timeframe: str) -> Optional[str]:
        """
        Get file path for specific indicator-symbol-timeframe combination.
        –ü–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä-—Å–∏–º–≤–æ–ª-—Ç–∞–π–º—Ñ—Ä–µ–π–º.
        
        Args:
            indicator: Indicator name
            symbol: Symbol name
            timeframe: Timeframe
            
        Returns:
            File path if exists, None otherwise
        """
        if indicator not in self.available_data:
            return None
        
        if symbol not in self.available_data[indicator]:
            return None
        
        for file_info in self.available_data[indicator][symbol]:
            if file_info['timeframe'] == timeframe:
                return file_info['file_path']
        
        return None
    
    def get_all_timeframes_for_symbol(self, symbol: str) -> List[str]:
        """
        Get all available timeframes for a symbol across all indicators.
        –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã –¥–ª—è —Å–∏–º–≤–æ–ª–∞ –ø–æ –≤—Å–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞–º.
        
        Args:
            symbol: Symbol name
            
        Returns:
            List of available timeframes
        """
        timeframes = set()
        
        for indicator in self.available_data:
            if symbol in self.available_data[indicator]:
                for file_info in self.available_data[indicator][symbol]:
                    timeframes.add(file_info['timeframe'])
        
        return sorted(timeframes, key=lambda x: self.timeframe_order.index(x) if x in self.timeframe_order else 999)
    
    def get_data_summary(self) -> Dict[str, Any]:
        """
        Get comprehensive data summary.
        –ü–æ–ª—É—á–∏—Ç—å –∫–æ–º–ø–ª–µ–∫—Å–Ω—É—é —Å–≤–æ–¥–∫—É –¥–∞–Ω–Ω—ã—Ö.
        
        Returns:
            Dictionary with data summary
        """
        summary = {
            'total_files': sum(
                len(files) for indicator in self.available_data 
                for files in self.available_data[indicator].values()
            ),
            'indicators': sorted(list(self.indicators)),
            'symbols': sorted(list(self.symbols)),
            'timeframes': sorted(list(self.timeframes)),
            'combinations': {}
        }
        
        # Calculate combinations
        for indicator in self.available_data:
            symbols = list(self.available_data[indicator].keys())
            summary['combinations'][indicator] = {
                'symbols': symbols,
                'count': len(symbols)
            }
        
        # Calculate total size
        total_size = 0
        for indicator in self.available_data:
            for symbol in self.available_data[indicator]:
                for file_info in self.available_data[indicator][symbol]:
                    total_size += file_info['size_mb']
        
        summary['total_size_mb'] = total_size
        summary['total_size_gb'] = total_size / 1024
        
        return summary
    
    def print_scan_results(self):
        """
        Print formatted scan results.
        –í—ã–≤–µ—Å—Ç–∏ –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.
        """
        print("\n" + "="*60)
        print("üîç AUTO DATA SCAN RESULTS")
        print("="*60)
        
        summary = self.get_data_summary()
        
        print(f"üìä Total Files: {summary['total_files']}")
        print(f"üìÅ Total Size: {summary['total_size_gb']:.2f} GB")
        print(f"üéØ Indicators: {', '.join(summary['indicators'])}")
        print(f"üí± Symbols: {', '.join(summary['symbols'])}")
        print(f"‚è∞ Timeframes: {', '.join(summary['timeframes'])}")
        
        print(f"\nüìã Available Combinations:")
        for indicator, info in summary['combinations'].items():
            print(f"   {indicator}: {info['count']} symbols ({', '.join(info['symbols'])})")
        
        print(f"\nüïê Timeframe Coverage:")
        for timeframe in self.timeframe_order:
            if timeframe in self.timeframes:
                count = sum(
                    1 for indicator in self.available_data
                    for symbol in self.available_data[indicator]
                    for file_info in self.available_data[indicator][symbol]
                    if file_info['timeframe'] == timeframe
                )
                print(f"   {timeframe}: {count} files")
        
        print("="*60)


class InteractiveDataSelector:
    """
    Interactive data selector for choosing indicators and symbols.
    –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Å–µ–ª–µ–∫—Ç–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤—ã–±–æ—Ä–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –∏ —Å–∏–º–≤–æ–ª–æ–≤.
    """
    
    def __init__(self, scanner: AutoDataScanner):
        """
        Initialize Interactive Data Selector.
        
        Args:
            scanner: AutoDataScanner instance
        """
        self.scanner = scanner
    
    def select_indicator(self) -> str:
        """
        Interactive indicator selection.
        –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –≤—ã–±–æ—Ä –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞.
        """
        indicators = sorted(self.scanner.indicators)
        
        if not indicators:
            print("‚ùå No indicators found!")
            return None
        
        print(f"\nüéØ Available Indicators:")
        for i, indicator in enumerate(indicators, 1):
            symbol_count = len(self.scanner.available_data[indicator])
            print(f"   {i}. {indicator} ({symbol_count} symbols)")
        
        while True:
            try:
                choice = input(f"\nSelect indicator (1-{len(indicators)}): ").strip()
                if choice.isdigit():
                    idx = int(choice) - 1
                    if 0 <= idx < len(indicators):
                        selected = indicators[idx]
                        print(f"‚úÖ Selected: {selected}")
                        return selected
                print("‚ùå Invalid choice. Please try again.")
            except (ValueError, KeyboardInterrupt):
                print("\n‚ùå Selection cancelled.")
                return None
    
    def select_symbol(self, indicator: str) -> str:
        """
        Interactive symbol selection for specific indicator.
        –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –≤—ã–±–æ—Ä —Å–∏–º–≤–æ–ª–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞.
        """
        if indicator not in self.scanner.available_data:
            print(f"‚ùå No data found for indicator: {indicator}")
            return None
        
        symbols = sorted(self.scanner.available_data[indicator].keys())
        
        if not symbols:
            print(f"‚ùå No symbols found for indicator: {indicator}")
            return None
        
        print(f"\nüí± Available Symbols for {indicator}:")
        for i, symbol in enumerate(symbols, 1):
            timeframe_count = len(self.scanner.available_data[indicator][symbol])
            timeframes = [f['timeframe'] for f in self.scanner.available_data[indicator][symbol]]
            print(f"   {i}. {symbol} ({timeframe_count} timeframes: {', '.join(timeframes)})")
        
        while True:
            try:
                choice = input(f"\nSelect symbol (1-{len(symbols)}): ").strip()
                if choice.isdigit():
                    idx = int(choice) - 1
                    if 0 <= idx < len(symbols):
                        selected = symbols[idx]
                        print(f"‚úÖ Selected: {selected}")
                        return selected
                print("‚ùå Invalid choice. Please try again.")
            except (ValueError, KeyboardInterrupt):
                print("\n‚ùå Selection cancelled.")
                return None
    
    def select_timeframes(self, indicator: str, symbol: str, auto_select_all: bool = True) -> List[str]:
        """
        Interactive timeframe selection.
        –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –≤—ã–±–æ—Ä —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤.
        
        Args:
            indicator: Selected indicator
            symbol: Selected symbol
            auto_select_all: If True, automatically select all available timeframes
            
        Returns:
            List of selected timeframes
        """
        timeframes = self.scanner.get_symbol_timeframes(indicator, symbol)
        
        if not timeframes:
            print(f"‚ùå No timeframes found for {indicator} {symbol}")
            return []
        
        if auto_select_all:
            print(f"‚úÖ Auto-selected all timeframes for {indicator} {symbol}: {', '.join(timeframes)}")
            return timeframes
        
        print(f"\n‚è∞ Available Timeframes for {indicator} {symbol}:")
        for i, timeframe in enumerate(timeframes, 1):
            print(f"   {i}. {timeframe}")
        
        print(f"   0. All timeframes")
        
        while True:
            try:
                choice = input(f"\nSelect timeframes (0 for all, or comma-separated numbers): ").strip()
                
                if choice == "0":
                    selected = timeframes
                    print(f"‚úÖ Selected all timeframes: {', '.join(selected)}")
                    return selected
                
                # Parse comma-separated choices
                choices = [int(x.strip()) - 1 for x in choice.split(',') if x.strip().isdigit()]
                if all(0 <= idx < len(timeframes) for idx in choices):
                    selected = [timeframes[idx] for idx in choices]
                    print(f"‚úÖ Selected timeframes: {', '.join(selected)}")
                    return selected
                
                print("‚ùå Invalid choice. Please try again.")
            except (ValueError, KeyboardInterrupt):
                print("\n‚ùå Selection cancelled.")
                return []
    
    def interactive_selection(self) -> Dict[str, Any]:
        """
        Complete interactive selection process.
        –ü–æ–ª–Ω—ã–π –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –≤—ã–±–æ—Ä–∞.
        
        Returns:
            Dictionary with selection results
        """
        print("\nüöÄ Interactive Data Selection")
        print("="*40)
        
        # Scan directory first
        scan_results = self.scanner.scan_directory()
        
        if not scan_results.get('scan_successful', False):
            print(f"‚ùå Scan failed: {scan_results.get('error', 'Unknown error')}")
            return {'success': False, 'error': scan_results.get('error')}
        
        # Print scan results
        self.scanner.print_scan_results()
        
        # Select indicator
        indicator = self.select_indicator()
        if not indicator:
            return {'success': False, 'error': 'No indicator selected'}
        
        # Select symbol
        symbol = self.select_symbol(indicator)
        if not symbol:
            return {'success': False, 'error': 'No symbol selected'}
        
        # Select timeframes
        timeframes = self.select_timeframes(indicator, symbol, auto_select_all=True)
        if not timeframes:
            return {'success': False, 'error': 'No timeframes selected'}
        
        # Prepare selection results
        selection = {
            'success': True,
            'indicator': indicator,
            'symbol': symbol,
            'timeframes': timeframes,
            'file_paths': {}
        }
        
        # Get file paths for all combinations
        for timeframe in timeframes:
            file_path = self.scanner.get_file_path(indicator, symbol, timeframe)
            if file_path:
                selection['file_paths'][timeframe] = file_path
            else:
                print(f"‚ö†Ô∏è File not found for {indicator} {symbol} {timeframe}")
        
        print(f"\n‚úÖ Selection completed:")
        print(f"   Indicator: {indicator}")
        print(f"   Symbol: {symbol}")
        print(f"   Timeframes: {', '.join(timeframes)}")
        print(f"   Files found: {len(selection['file_paths'])}")
        
        return selection


def main():
    """
    Main function for testing auto data scanner.
    –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–∫–∞–Ω–µ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö.
    """
    # Initialize scanner
    scanner = AutoDataScanner()
    
    # Scan directory
    print("üîç Scanning data directory...")
    scan_results = scanner.scan_directory()
    
    if scan_results.get('scan_successful'):
        scanner.print_scan_results()
        
        # Test interactive selection
        selector = InteractiveDataSelector(scanner)
        selection = selector.interactive_selection()
        
        if selection.get('success'):
            print(f"\nüéâ Selection successful!")
            print(f"Selected: {selection['indicator']} {selection['symbol']} {selection['timeframes']}")
        else:
            print(f"\n‚ùå Selection failed: {selection.get('error')}")
    else:
        print(f"‚ùå Scan failed: {scan_results.get('error')}")


if __name__ == "__main__":
    main()
